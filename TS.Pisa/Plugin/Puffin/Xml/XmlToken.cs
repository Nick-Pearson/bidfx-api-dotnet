using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace TS.Pisa.Plugin.Puffin.Xml
{
    /// <summary>
    /// This class provides an Xml token that may be generated by an Xml parser or
    /// used to represent a component part of a compressed Xml message in
    /// inter-process communication.
    /// </summary>
    /// <remarks>
    /// This class provides an Xml token that may be generated by an Xml parser or
    /// used to represent a component part of a compressed Xml message in
    /// inter-process communication.  An Xml parser typically breaks the incoming
    /// Xml into Tokens, each with a type and associated text string.  This class
    /// provides access to this information.
    /// </remarks>
    /// <author>Paul Sweeny</author>
    public class XmlToken
    {
        public static readonly XmlToken EmptyToken = new XmlToken(Xml.TokenType.TagEndEmptyContent, "", null);
        public static readonly XmlToken NullValueToken = new XmlToken(Xml.TokenType.AttributeValueString, "", null);
        public static readonly XmlToken NullContentToken = new XmlToken(Xml.TokenType.NestedContent, "", null);
        public static readonly XmlToken ZeroToken = IntegerValue(0);

        private readonly TokenType _tokenType;
        private readonly string _text;
        private readonly object _value;

        public XmlToken(TokenType tokenType, string text, object value)
        {
            _tokenType = tokenType;
            _text = text;
            _value = value;
        }

        public static XmlToken StartTag(string value)
        {
            return new XmlToken(Xml.TokenType.TagStart, value, value);
        }

        public static XmlToken AttributeName(string value)
        {
            return new XmlToken(Xml.TokenType.AttributeName, value, value);
        }

        public static XmlToken StringValue(string value)
        {
            return new XmlToken(Xml.TokenType.AttributeValueString, value, value);
        }

        public static XmlToken IntegerValue(int value)
        {
            return new XmlToken(Xml.TokenType.AttributeValueInteger, value.ToString(), value);
        }

        public static XmlToken LongValue(long value)
        {
            return new XmlToken(Xml.TokenType.AttributeValueInteger, value.ToString(), value);
        }

        public static XmlToken DoubleValue(double value)
        {
            return new XmlToken(Xml.TokenType.AttributeValueDouble, value.ToString(CultureInfo.InvariantCulture), value);
        }

        public static XmlToken BooleanValue(bool value)
        {
            return new XmlToken(Xml.TokenType.AttributeValueString, value ? "true" : "false", value);
        }

        public XmlToken ToEndTag()
        {
            return new XmlToken(Xml.TokenType.TagEnd, _text, _value);
        }

        public TokenType TokenType()
        {
            return _tokenType;
        }

        public bool IsEndTag()
        {
            return _tokenType == Xml.TokenType.TagEnd;
        }

        public bool IsEmptyTag()
        {
            return _tokenType == Xml.TokenType.TagEndEmptyContent;
        }

        public bool IsStartTag()
        {
            return _tokenType == Xml.TokenType.TagStart;
        }

        public bool IsTagContent()
        {
            return _tokenType == Xml.TokenType.NestedContent;
        }

        public bool IsAttributeName()
        {
            return _tokenType == Xml.TokenType.AttributeName;
        }

        public bool IsValueType()
        {
            return _tokenType >= Xml.TokenType.AttributeValueInteger;
        }

        public bool IsNumberType()
        {
            return _tokenType == Xml.TokenType.AttributeValueInteger ||
                   _tokenType == Xml.TokenType.AttributeValueDouble ||
                   _tokenType == Xml.TokenType.AttributeValueFraction;
        }

        public bool IsNull()
        {
            return false;
        }

        public bool IsInteger()
        {
            return _tokenType == Xml.TokenType.AttributeValueInteger;
        }

        public bool IsDouble()
        {
            return _tokenType == Xml.TokenType.AttributeValueDouble;
        }

        public bool IsFraction()
        {
            return _tokenType == Xml.TokenType.AttributeValueFraction;
        }

        public bool IsString()
        {
            return _tokenType == Xml.TokenType.AttributeValueString;
        }

        public bool IsNegative()
        {
            return _text.StartsWith("-");
        }

        public string GetText()
        {
            return _text;
        }

        public object GetValue()
        {
            return _value;
        }

        public int Length()
        {
            return _text.Length;
        }

        public override string ToString()
        {
            return _text;
        }

        public int ToInteger()
        {
            if (IsInteger())
            {
                return Convert.ToInt32(ToString());
            }
            return (int) ToDouble();
        }

        public long ToLong()
        {
            if (IsInteger())
            {
                return Convert.ToInt64(ToString());
            }
            return (long) ToDouble();
        }

        public double ToDouble()
        {
            if (IsDouble() || IsInteger())
            {
                return TextAsDouble();
            }
            return FractionToDouble(ToString());
        }

        public static double FractionToDouble(string fraction)
        {
            try
            {
                int slash = fraction.IndexOf('/');
                if (slash == -1)
                {
                    if (fraction.IndexOf('.') == -1)
                    {
                        return Convert.ToInt64(fraction);
                    }
                    return double.Parse(fraction);
                }
                double denominator = Convert.ToInt32(fraction.Substring(slash + 1, fraction.Length));
                int space = fraction.IndexOf(' ');
                if (space == -1)
                {
                    return Convert.ToInt32(fraction.Substring(0, slash)) / denominator;
                }
                double whole = Math.Abs(Convert.ToInt32(fraction.Substring(0, space)));
                double numerator = Convert.ToInt32(fraction.Substring(space + 1, slash));
                double abs = whole + numerator / denominator;
                return fraction[0] == '-' ? -abs : abs;
            }
            catch (Exception e)
            {
                throw new FormatException("invalid fraction " + fraction, e);
            }
        }

        private double TextAsDouble()
        {
            return double.Parse(ToString());
        }

        public bool ToBoolean()
        {
            return Convert.ToBoolean(ToString());
        }

        public override bool Equals(object o)
        {
            if (o == this)
            {
                return true;
            }
            if (!(o is XmlToken)) return false;
            var token = (XmlToken) o;
            return _tokenType == token._tokenType && _text.Equals(token._text);
        }

        public string DebugString()
        {
            return "token " + _tokenType + " [" + ToString() + ']';
        }

        public override int GetHashCode()
        {
            return _tokenType.GetHashCode() + (_text.GetHashCode() << 4);
        }
    }
}